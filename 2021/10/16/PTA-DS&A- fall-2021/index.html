<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Function01-复杂度3 二分查找 (20 分)本题要求实现二分查找算法。">
<meta property="og:type" content="article">
<meta property="og:title" content="中国大学MOOC-陈越、何钦铭-数据结构-2021秋">
<meta property="og:url" content="http://example.com/2021/10/16/PTA-DS&A-%20fall-2021/index.html">
<meta property="og:site_name" content="Memory Dot">
<meta property="og:description" content="Function01-复杂度3 二分查找 (20 分)本题要求实现二分查找算法。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2021/11/6952cdeb331ca65c.jpg">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2021/10/aba50c13696cb518.png">
<meta property="article:published_time" content="2021-10-16T12:25:25.174Z">
<meta property="article:modified_time" content="2021-11-06T12:13:10.151Z">
<meta property="article:author" content="Huang Jinhong">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2021/11/6952cdeb331ca65c.jpg">

<link rel="canonical" href="http://example.com/2021/10/16/PTA-DS&A-%20fall-2021/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>中国大学MOOC-陈越、何钦铭-数据结构-2021秋 | Memory Dot</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Memory Dot</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/16/PTA-DS&A-%20fall-2021/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Jinhong">
      <meta itemprop="description" content="“我们来到这世上是为的是看太阳”">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Memory Dot">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          中国大学MOOC-陈越、何钦铭-数据结构-2021秋
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-16 20:25:25" itemprop="dateCreated datePublished" datetime="2021-10-16T20:25:25+08:00">2021-10-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-06 20:13:10" itemprop="dateModified" datetime="2021-11-06T20:13:10+08:00">2021-11-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/data-structure-algorithm/" itemprop="url" rel="index"><span itemprop="name">data structure & algorithm</span></a>
                </span>
            </span>

          
            <span id="/2021/10/16/PTA-DS&A-%20fall-2021/" class="post-meta-item leancloud_visitors" data-flag-title="中国大学MOOC-陈越、何钦铭-数据结构-2021秋" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/10/16/PTA-DS&A-%20fall-2021/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/10/16/PTA-DS&A-%20fall-2021/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><h2 id="01-复杂度3-二分查找-20-分"><a href="#01-复杂度3-二分查找-20-分" class="headerlink" title="01-复杂度3 二分查找 (20 分)"></a><strong>01-复杂度3 二分查找 (20 分)</strong></h2><p>本题要求实现二分查找算法。</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">BinarySearch</span><span class="params">( List L, ElementType X )</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">1</span>, right = L-&gt;Last, mid;</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (X &lt; L-&gt;Data[mid]) right = mid - <span class="number">1</span>; <span class="comment">//updata right</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; L-&gt;Data[mid]) left = mid + <span class="number">1</span>; <span class="comment">//updata left</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> mid; <span class="comment">// if (X == Data[mid])</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> NotFound; <span class="comment">//when left &gt; right, it is malposed that meant not find &#x27;X&#x27;, so return NotFound</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：<br>想一想这个说法是否正确？在二分查找的程序实现中，如果left和right的更新不是取mid+1和mid-1而是都取mid，程序也是正确的。</p>
<details>
<summary>答案</summary>
这个说法是错误的 。
考虑查找值大于数组内最大值的情况，如果都取mid，循环到只有两元素时就会导致mid始终与左边界值相等，从而程序**无限循环**；考虑查找值小于数组内最小值的情况，由于可能存在数列中仅有一个元素的情况所以进入循环的条件必须要包含left==right，在此前提下，循环到最后左右边界与mid将会重合从而无限循环。
</details>
## 02-线性结构1 两个有序链表序列的合并 (15 分)

<p>本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">( List L1, List L2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L, rear, temp;</span><br><span class="line">    L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node)); L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    rear = L;</span><br><span class="line">    <span class="keyword">while</span> ( L1-&gt;Next &amp;&amp; L2-&gt;Next ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L1-&gt;Next-&gt;Data &lt; L2-&gt;Next-&gt;Data) &#123;</span><br><span class="line">            temp = L1-&gt;Next;</span><br><span class="line">            L1-&gt;Next = temp-&gt;Next;</span><br><span class="line">            rear-&gt;Next = temp;</span><br><span class="line">            rear = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (L1-&gt;Next-&gt;Data &gt; L2-&gt;Next-&gt;Data) &#123;</span><br><span class="line">            temp = L2-&gt;Next;</span><br><span class="line">            L2-&gt;Next = temp-&gt;Next;</span><br><span class="line">            rear-&gt;Next = temp;</span><br><span class="line">            rear = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = L1-&gt;Next;</span><br><span class="line">            L1-&gt;Next = temp-&gt;Next;</span><br><span class="line">            rear-&gt;Next = temp;</span><br><span class="line">            rear = temp;</span><br><span class="line"></span><br><span class="line">            temp = L2-&gt;Next;</span><br><span class="line">            L2-&gt;Next = temp-&gt;Next;</span><br><span class="line">            rear-&gt;Next = temp;</span><br><span class="line">            rear = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L1-&gt;Next) &#123;</span><br><span class="line">        rear-&gt;Next = L1-&gt;Next;</span><br><span class="line">        L1-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L2-&gt;Next) &#123;</span><br><span class="line">        rear-&gt;Next = L2-&gt;Next;</span><br><span class="line">        L2-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：注意非递减的意思是，不严格递增。也就是说，<strong>当遇到两个相同的数字时，两个数字都要合并进去</strong>。</p>
<h2 id="04-树7-二叉搜索树的操作集-30-分"><a href="#04-树7-二叉搜索树的操作集-30-分" class="headerlink" title="04-树7 二叉搜索树的操作集 (30 分)"></a><strong>04-树7 二叉搜索树的操作集 (30 分)</strong></h2><p><em>完成日期：21.11.06</em></p>
<p>本题要求实现给定二叉搜索树的5种常用操作。</p>
<p><strong>函数接口定义：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中<code>BinTree</code>结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数<code>Insert</code>将<code>X</code>插入二叉搜索树<code>BST</code>并返回结果树的根结点指针；</li>
<li>函数<code>Delete</code>将<code>X</code>从二叉搜索树<code>BST</code>中删除，并返回结果树的根结点指针；如果<code>X</code>不在树中，则打印一行<code>Not Found</code>并返回原树的根结点指针；</li>
<li>函数<code>Find</code>在二叉搜索树<code>BST</code>中找到<code>X</code>，返回该结点的指针；如果找不到则返回空指针；</li>
<li>函数<code>FindMin</code>返回二叉搜索树<code>BST</code>中最小元结点的指针；</li>
<li>函数<code>FindMax</code>返回二叉搜索树<code>BST</code>中最大元结点的指针。</li>
</ul>
<p><strong>裁判测试程序样例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversal</span><span class="params">( BinTree BT )</span></span>; <span class="comment">/* 先序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversal</span><span class="params">( BinTree BT )</span></span>;  <span class="comment">/* 中序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree BST, MinP, MaxP, Tmp;</span><br><span class="line">    ElementType X;</span><br><span class="line">    <span class="keyword">int</span> N, i;</span><br><span class="line"></span><br><span class="line">    BST = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        BST = <span class="built_in">Insert</span>(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Preorder:&quot;</span>); <span class="built_in">PreorderTraversal</span>(BST); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    MinP = <span class="built_in">FindMin</span>(BST);</span><br><span class="line">    MaxP = <span class="built_in">FindMax</span>(BST);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        Tmp = <span class="built_in">Find</span>(BST, X);</span><br><span class="line">        <span class="keyword">if</span> (Tmp == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d is not found\n&quot;</span>, X);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is found\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MinP) <span class="built_in">printf</span>(<span class="string">&quot;%d is the smallest key\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MaxP) <span class="built_in">printf</span>(<span class="string">&quot;%d is the largest key\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        BST = <span class="built_in">Delete</span>(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Inorder:&quot;</span>); <span class="built_in">InorderTraversal</span>(BST); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure>

<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">5 8 6 2 4 1 0 10 9 7</span><br><span class="line">5</span><br><span class="line">6 3 10 0 5</span><br><span class="line">5</span><br><span class="line">5 7 0 10 3结尾无空行</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Preorder: 5 2 1 0 4 8 6 7 10 9</span><br><span class="line">6 is found</span><br><span class="line">3 is not found</span><br><span class="line">10 is found</span><br><span class="line">10 is the largest key</span><br><span class="line">0 is found</span><br><span class="line">0 is the smallest key</span><br><span class="line">5 is found</span><br><span class="line">Not Found</span><br><span class="line">Inorder: 1 2 4 6 8 9结尾无空行</span><br></pre></td></tr></table></figure>

<p><strong>AC code：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Insert根据搜索二叉树左小右大的特点设置，以建立一个搜索二叉树</span></span><br><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入操作</span></span><br><span class="line">    <span class="keyword">if</span> (BST == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        BST = (BinTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TNode)); <span class="comment">//开辟树结点空间</span></span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">        BST-&gt;Left = <span class="literal">NULL</span>;</span><br><span class="line">        BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到插入结点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; BST-&gt;Data)</span><br><span class="line">        BST-&gt;Right = Insert(BST-&gt;Right, X);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; BST-&gt;Data)</span><br><span class="line">        BST-&gt;Left = Insert(BST-&gt;Left, X);</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Find根据搜索二叉树左小右大的特点设置，以查找目标元素</span></span><br><span class="line"><span class="comment">//返回值是树结点的地址&#x27;Position&#x27;</span></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( BinTree BST, ElementType X )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回目标元素所在二叉树，注意，返回的是树结点，不是元素数值</span></span><br><span class="line">    <span class="keyword">if</span> (BST == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//没找到返回NULL</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X == BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> BST;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到目标元素所在树结点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find (BST-&gt;Right, X);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find (BST-&gt;Left, X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FindMin根据搜索二叉树左小右大的特点设置，以查找最小元素</span></span><br><span class="line"><span class="comment">//返回值是树结点的地址&#x27;Position&#x27;</span></span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BST == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//树是空的，找不了返回NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//树的最左端是最小元素</span></span><br><span class="line">    <span class="keyword">while</span> (BST-&gt;Left != <span class="literal">NULL</span>) </span><br><span class="line">        BST = BST-&gt;Left;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FindMax根据搜索二叉树左小右大的特点设置，以查找最大元素</span></span><br><span class="line"><span class="comment">//返回值是树结点的地址&#x27;Position&#x27;</span></span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BST == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//树是空的，找不了返回NULL</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//树的最右端是最小元素</span></span><br><span class="line">    <span class="keyword">while</span> (BST-&gt;Right != <span class="literal">NULL</span>)</span><br><span class="line">        BST = BST-&gt;Right;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Delete根据搜索二叉树左小右大的特点设置，以删除目标元素所在树结点</span></span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span></span>&#123;</span><br><span class="line">    BinTree temp; <span class="comment">//temp暂时是个空的树结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//找不到，返回&quot;Not Found\n&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (BST == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//找得到</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//找到要删除的树结点</span></span><br><span class="line">        <span class="keyword">if</span> (X &lt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Left = Delete(BST-&gt;Left, X);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Right = Delete(BST-&gt;Right, X);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行删除</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果该结点的左、右子树都存在（不妨命名该结点为&#x27;TNodeA&#x27;）</span></span><br><span class="line">            <span class="keyword">if</span> (BST-&gt;Left &amp;&amp; BST-&gt;Right)&#123;</span><br><span class="line">                temp = FindMin(BST-&gt;Right); <span class="comment">//将TNodeA的右子树最小结点赋给temp</span></span><br><span class="line">                BST-&gt;Data = temp-&gt;Data; <span class="comment">//将TNodeA的右子树最小结点的值给自己，完成删除TNodeA</span></span><br><span class="line">                BST-&gt;Right = Delete(BST-&gt;Right, temp-&gt;Data);  <span class="comment">//记得还要删掉TNodeA的右子树最小结点</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果该结点的左、右子树只有一棵存在，或者两棵都不存在（不妨命名该结点为&#x27;TNodeB&#x27;）</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp = BST; <span class="comment">//将TNodeB本身赋给temp</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果TNodeB的左子树不存在，即TNodeB的右子树存在</span></span><br><span class="line">                <span class="keyword">if</span> (BST-&gt;Left == <span class="literal">NULL</span>) </span><br><span class="line">                    BST = BST-&gt;Right; <span class="comment">//将TNodeB的右子树赋给自己，完成删除TNodeB</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果TNodeB的右子树不存在，即TNodeB的左子树存在</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (BST-&gt;Right == <span class="literal">NULL</span>)</span><br><span class="line">                    BST = BST-&gt;Left;<span class="comment">//将TNodeB的左子树赋给自己，完成删除TNodeB</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//记得还要通过temp释放原本的TNodeB（这也是TNodeB左、右两棵子树都不存在的情况）</span></span><br><span class="line">                <span class="built_in">free</span>(temp); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路：</strong></p>
<ul>
<li>根据<strong>搜索二叉树左小右大</strong>的特点设置函数。</li>
<li>时常利用递归。</li>
<li>多考虑树节点为空的情况。</li>
</ul>
<p><strong>本地AC code：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversal</span><span class="params">( BinTree BT )</span></span>; <span class="comment">/* 先序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversal</span><span class="params">( BinTree BT )</span></span>;  <span class="comment">/* 中序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree BST, MinP, MaxP, Tmp;</span><br><span class="line">    ElementType X;</span><br><span class="line">    <span class="keyword">int</span> N, i;</span><br><span class="line"></span><br><span class="line">    BST = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        BST = Insert(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Preorder:&quot;</span>); PreorderTraversal(BST); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    MinP = FindMin(BST);</span><br><span class="line">    MaxP = FindMax(BST);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        Tmp = Find(BST, X);</span><br><span class="line">        <span class="keyword">if</span> (Tmp == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d is not found\n&quot;</span>, X);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is found\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MinP) <span class="built_in">printf</span>(<span class="string">&quot;%d is the smallest key\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MaxP) <span class="built_in">printf</span>(<span class="string">&quot;%d is the largest key\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        BST = Delete(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Inorder:&quot;</span>); InorderTraversal(BST); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversal</span><span class="params">( BinTree BT )</span> <span class="comment">//先序遍历，重复递归即可</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BT == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, BT-&gt;Data);</span><br><span class="line">    PreorderTraversal( BT-&gt;Left);</span><br><span class="line">    PreorderTraversal( BT-&gt;Right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversal</span><span class="params">( BinTree BT )</span> <span class="comment">//中序遍历，重复递归即可</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BT == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    InorderTraversal( BT-&gt;Left );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, BT-&gt;Data);</span><br><span class="line">    InorderTraversal( BT-&gt;Right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Insert根据搜索二叉树左小右大的特点设置，以建立一个搜索二叉树</span></span><br><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入操作</span></span><br><span class="line">    <span class="keyword">if</span> (BST == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        BST = (BinTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TNode)); <span class="comment">//开辟树结点空间</span></span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">        BST-&gt;Left = <span class="literal">NULL</span>;</span><br><span class="line">        BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到插入结点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; BST-&gt;Data)</span><br><span class="line">        BST-&gt;Right = Insert(BST-&gt;Right, X);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; BST-&gt;Data)</span><br><span class="line">        BST-&gt;Left = Insert(BST-&gt;Left, X);</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Find根据搜索二叉树左小右大的特点设置，以查找目标元素</span></span><br><span class="line"><span class="comment">//返回值是树结点的地址&#x27;Position&#x27;</span></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( BinTree BST, ElementType X )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回目标元素所在二叉树，注意，返回的是树结点，不是元素数值</span></span><br><span class="line">    <span class="keyword">if</span> (BST == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//没找到返回NULL</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X == BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> BST;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到目标元素所在树结点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find (BST-&gt;Right, X);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find (BST-&gt;Left, X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FindMin根据搜索二叉树左小右大的特点设置，以查找最小元素</span></span><br><span class="line"><span class="comment">//返回值是树结点的地址&#x27;Position&#x27;</span></span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BST == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//树是空的，找不了返回NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//树的最左端是最小元素</span></span><br><span class="line">    <span class="keyword">while</span> (BST-&gt;Left != <span class="literal">NULL</span>) </span><br><span class="line">        BST = BST-&gt;Left;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FindMax根据搜索二叉树左小右大的特点设置，以查找最大元素</span></span><br><span class="line"><span class="comment">//返回值是树结点的地址&#x27;Position&#x27;</span></span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BST == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//树是空的，找不了返回NULL</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//树的最右端是最小元素</span></span><br><span class="line">    <span class="keyword">while</span> (BST-&gt;Right != <span class="literal">NULL</span>)</span><br><span class="line">        BST = BST-&gt;Right;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Delete根据搜索二叉树左小右大的特点设置，以删除目标元素所在树结点</span></span><br><span class="line"></span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span></span>&#123;</span><br><span class="line">    BinTree temp; <span class="comment">//temp暂时是个空的树结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//找不到，返回&quot;Not Found\n&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (BST == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//找得到</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//找到要删除的树结点</span></span><br><span class="line">        <span class="keyword">if</span> (X &lt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Left = Delete(BST-&gt;Left, X);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Right = Delete(BST-&gt;Right, X);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行删除</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果该结点的左、右子树都存在（不妨命名该结点为&#x27;TNodeA&#x27;）</span></span><br><span class="line">            <span class="keyword">if</span> (BST-&gt;Left &amp;&amp; BST-&gt;Right)&#123;</span><br><span class="line">                temp = FindMin(BST-&gt;Right); <span class="comment">//将TNodeA的右子树最小结点赋给temp</span></span><br><span class="line">                BST-&gt;Data = temp-&gt;Data; <span class="comment">//将TNodeA的右子树最小结点的值给自己，完成删除TNodeA</span></span><br><span class="line">                BST-&gt;Right = Delete(BST-&gt;Right, temp-&gt;Data);  <span class="comment">//记得还要删掉TNodeA的右子树最小结点</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果该结点的左、右子树只有一棵存在，或者两棵都不存在（不妨命名该结点为&#x27;TNodeB&#x27;）</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp = BST; <span class="comment">//将TNodeB本身赋给temp</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果TNodeB的左子树不存在，即TNodeB的右子树存在</span></span><br><span class="line">                <span class="keyword">if</span> (BST-&gt;Left == <span class="literal">NULL</span>) </span><br><span class="line">                    BST = BST-&gt;Right; <span class="comment">//将TNodeB的右子树赋给自己，完成删除TNodeB</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果TNodeB的右子树不存在，即TNodeB的左子树存在</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (BST-&gt;Right == <span class="literal">NULL</span>)</span><br><span class="line">                    BST = BST-&gt;Left;<span class="comment">//将TNodeB的左子树赋给自己，完成删除TNodeB</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//记得还要通过temp释放原本的TNodeB（这也是TNodeB左、右两棵子树都不存在的情况）</span></span><br><span class="line">                <span class="built_in">free</span>(temp); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h1><h2 id="01-复杂度1-最大子列和问题-20-分"><a href="#01-复杂度1-最大子列和问题-20-分" class="headerlink" title="01-复杂度1 最大子列和问题 (20 分)"></a><strong>01-复杂度1 最大子列和问题 (20 分)</strong></h2><p>给定<em>K</em>个整数组成的序列{ <em>N</em>1, <em>N</em>2, …, <em>NK</em> }，“连续子列”被定义为{ <em>Ni</em>, <em>Ni</em>+1, …, <em>Nj</em> }，其中 1≤<em>i</em>≤<em>j</em>≤<em>K</em>。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。<br>本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：</p>
<ul>
<li>数据1：与样例等价，测试基本正确性；</li>
<li>数据2：10^2个随机整数；</li>
<li>数据3：10^3个随机整数；</li>
<li>数据4：10^4个随机整数；</li>
<li>数据5：10^5个随机整数；</li>
</ul>
<p><strong>输入格式</strong>:<br>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p>
<p><strong>输出格式</strong>:<br>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出<code>0 0</code>。</p>
<p><strong>输入样例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">-2 11 -4 13 -5 -2</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>

<p><strong>答案</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N);</span><br><span class="line">    <span class="keyword">int</span> A[N];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span> ;i&lt;N ;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;A[i]);              <span class="comment">//scanf是存储于地址当中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,MaxSubseqSum2(A, N));   <span class="comment">//输入指针地址 A</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;      <span class="comment">//此时数组即是首地址，也可以用*A表示</span></span><br><span class="line">    <span class="keyword">int</span> ThisSum, MaxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        ThisSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = i; j &lt; n; j++)&#123;</span><br><span class="line">           ThisSum += a[j];</span><br><span class="line">            <span class="keyword">if</span>(ThisSum &gt; MaxSum)<span class="comment">//比较当前子列和与预设最大子列和</span></span><br><span class="line">            MaxSum = ThisSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum; <span class="comment">//O(N^2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路：用数组实现，<code>MaxSubseqSum2</code>使用两个for循环，比较<strong>当前子列和</strong>与<strong>预设最大子列和</strong>。</p>
<h2 id="01-复杂度2-Maximum-Subsequence-Sum-25-分"><a href="#01-复杂度2-Maximum-Subsequence-Sum-25-分" class="headerlink" title="01-复杂度2 Maximum Subsequence Sum (25 分)"></a><strong>01-复杂度2 Maximum Subsequence Sum (25 分)</strong></h2><p>Given a sequence of <em>K</em> integers { <em>N</em>1, <em>N</em>2, …, <em>NK</em> }. A continuous subsequence is defined to be { <em>Ni</em>, <em>Ni</em>+1, …, <em>Nj</em> } where 1≤<em>i</em>≤<em>j</em>≤<em>K</em>. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p>
<p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>
<p><strong>Input Specification:</strong></p>
<p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer <em>K</em> (≤10000). The second line contains <em>K</em> numbers, separated by a space.</p>
<p><strong>Output Specification:</strong></p>
<p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices <em>i</em> and <em>j</em> (as shown by the sample case). If all the <em>K</em> numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>
<p><strong>Sample Input:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">-10 1 2 3 4 -5 -23 3 7 -21</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>

<p><strong>Sample Output:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 1 4</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>

<p><strong>AC code:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*double for loop algorithm*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">MaxSubseqSum2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> N)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N);</span><br><span class="line">    <span class="keyword">int</span> A[N];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span> ;i&lt;N ;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;A[i]);         </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,*(MaxSubseqSum2(A, N)), *(MaxSubseqSum2(A, N) + <span class="number">1</span>), *(MaxSubseqSum2(A, N) + <span class="number">2</span>));   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">MaxSubseqSum2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">  <span class="keyword">int</span> first, last, ThisSum, MaxSum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> ret[<span class="number">3</span>]; </span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    ThisSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = i; j &lt; n; j++)&#123;</span><br><span class="line">      ThisSum += a[j];</span><br><span class="line">      <span class="keyword">if</span>(ThisSum &gt; MaxSum)&#123;<span class="comment">//比较当前子列和与预设最大子列和</span></span><br><span class="line">        MaxSum = ThisSum;</span><br><span class="line">        first = a[i];<span class="comment">//设置最大子列和的第一个元素</span></span><br><span class="line">        last = a[j];<span class="comment">//设置最大子列和的最后一个元素</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(MaxSum == <span class="number">0</span>)&#123; </span><br><span class="line">    first = a[<span class="number">0</span>]; <span class="comment">//序列全是负整数的情况</span></span><br><span class="line">    last = a[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n ;i++)<span class="comment">//序列全是非正整数的情况，即至少有一个0和其它负数</span></span><br><span class="line">      <span class="keyword">if</span>(a[i] == <span class="number">0</span>)&#123;</span><br><span class="line">        first = last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ret[<span class="number">0</span>] = MaxSum;</span><br><span class="line">  ret[<span class="number">1</span>] = first;</span><br><span class="line">  ret[<span class="number">2</span>] = last;</span><br><span class="line">  <span class="keyword">return</span> ret; <span class="comment">//O(N^2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Reference</strong> <strong>AC code:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*online algorithm*/</span></span><br><span class="line"><span class="comment">/*这是其它博主根据在线算法写的，作为参考*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIEZ 10000</span></span><br><span class="line"><span class="keyword">int</span> a[MAXSIEZ];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">online</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp_Left = <span class="number">0</span>, right = <span class="number">0</span>, left = <span class="number">0</span>;<span class="comment">//temp_Left为临时左下标，left为最大子序列最左边下标，right为最右边下标</span></span><br><span class="line">    <span class="keyword">int</span> ThisSum = <span class="number">0</span>, MaxSum = <span class="number">-1</span>;<span class="comment">//首先ThisSum代表临时子列和，MaxSum为最大子列和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ThisSum += a[i];</span><br><span class="line">        <span class="keyword">if</span> (ThisSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ThisSum = <span class="number">0</span>;</span><br><span class="line">            temp_Left = i+<span class="number">1</span>;<span class="comment">//更新临时下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ThisSum &gt; MaxSum) &#123;</span><br><span class="line">            MaxSum = ThisSum;</span><br><span class="line">            left =  temp_Left;<span class="comment">//更新左下标</span></span><br><span class="line">            right = i;<span class="comment">//右下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (MaxSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0 %d %d&quot;</span>, a[<span class="number">0</span>], a[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, MaxSum, a[left], a[right]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//O(NlogN)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;data.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    online();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：要区分两种特殊情况。</p>
<ul>
<li>至少有一个零，输出结果为 <code>0 0 0</code></li>
<li>全都是负数，输出结果为 <code>0 first_neg_number last_neg_number </code></li>
</ul>
<h2 id="02-线性结构2-一元多项式的乘法与加法运算-20-分"><a href="#02-线性结构2-一元多项式的乘法与加法运算-20-分" class="headerlink" title="02-线性结构2 一元多项式的乘法与加法运算 (20 分)"></a><strong>02-线性结构2 一元多项式的乘法与加法运算 (20 分)</strong></h2><p>设计函数分别求两个一元多项式的乘积与和。</p>
<p><strong>输入格式:</strong></p>
<p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p>
<p><strong>输出格式:</strong></p>
<p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出<code>0 0</code>。</p>
<p><strong>输入样例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>

<p><strong>答案</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> coef; <span class="comment">//系数</span></span><br><span class="line">    <span class="keyword">int</span> expon; <span class="comment">//指数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PolyNode</span> *<span class="title">Polynomial</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="comment">//Compare(a, b)函数，若a &gt; b，返回1；若a &lt; b，返回-1；若a == b，返回0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> e, Polynomial *pRear)</span></span>&#123;</span><br><span class="line">    Polynomial P;</span><br><span class="line">    P = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">    P-&gt;coef = c;</span><br><span class="line">    P-&gt;expon = e;</span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    (*pRear)-&gt;link = P;</span><br><span class="line">    *pRear = P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">ReadPoly</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Polynomial P, Rear, t;</span><br><span class="line">    <span class="keyword">int</span> c, e, N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    P = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">    P-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    Rear = P;</span><br><span class="line">    <span class="keyword">while</span> (N--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;c, &amp;e);</span><br><span class="line">        Attach(c, e, &amp;Rear);</span><br><span class="line">    &#125;</span><br><span class="line">    t = P; P = P-&gt;link; <span class="built_in">free</span>(t);</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">Add</span><span class="params">(Polynomial P1, Polynomial P2)</span></span>&#123;</span><br><span class="line">    Polynomial front, rear, t;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    rear = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">    front = rear;</span><br><span class="line">    <span class="keyword">while</span> (P1&amp;&amp;P2)&#123;</span><br><span class="line">        <span class="keyword">switch</span> (compare(P1-&gt;expon, P2-&gt;expon))&#123; <span class="comment">//判别多项式尾部rear插入哪一项</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">            P1 = P1-&gt;link;    </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);</span><br><span class="line">            P2 = P2-&gt;link;    </span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            sum = P1-&gt;coef + P2-&gt;coef;</span><br><span class="line">            <span class="keyword">if</span> (sum) Attach(sum, P1-&gt;expon, &amp;rear);</span><br><span class="line">            P1 = P1-&gt;link;</span><br><span class="line">            P2 = P2-&gt;link;    </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; P1; P1 = P1-&gt;link) Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);</span><br><span class="line">    <span class="keyword">for</span>(; P2; P2 = P2-&gt;link) Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);</span><br><span class="line">    rear-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    t = front; front = front-&gt;link; <span class="built_in">free</span>(t);</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polynomial <span class="title">Mult</span><span class="params">(Polynomial P1, Polynomial P2)</span></span>&#123; <span class="comment">//逐项插入的解法，先用t1第一项历遍t2作为P，再用t1第二项、t2第三项...逐个历遍t2，同时每历遍一次插入一次P</span></span><br><span class="line">    Polynomial P, Rear, t1, t2, t;</span><br><span class="line">    <span class="keyword">int</span> c, e;</span><br><span class="line">    <span class="keyword">if</span> (!P1 || !P2) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    t1 = P1; t2 = P2;</span><br><span class="line">    P = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode)); P-&gt;link = <span class="literal">NULL</span>; <span class="comment">//设置首部空结点</span></span><br><span class="line">    Rear = P;</span><br><span class="line">    <span class="keyword">while</span> (t2) &#123; <span class="comment">//先用P1的第一项乘以P2，得到P</span></span><br><span class="line">        Attach(t1-&gt;coef * t2-&gt;coef, t1-&gt;expon + t2-&gt;expon, &amp;Rear);</span><br><span class="line">        t2 = t2-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    t1 = t1-&gt;link;</span><br><span class="line">    <span class="keyword">while</span> (t1)&#123;</span><br><span class="line">        t2 = P2; Rear = P;</span><br><span class="line">        <span class="keyword">while</span> (t2)&#123;</span><br><span class="line">            e = t1-&gt;expon + t2-&gt;expon;</span><br><span class="line">            c = t1-&gt;coef * t2-&gt;coef;</span><br><span class="line">            <span class="keyword">while</span> (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e) <span class="comment">//rear下一项不为空，移动rear，直到rear下一项指数不大于插入项指数</span></span><br><span class="line">                Rear = Rear-&gt;link; <span class="comment">//移动rear</span></span><br><span class="line">            <span class="keyword">if</span> (Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e) &#123;<span class="comment">//rear下一项不为空，且rear下一项指数和插入项指数相等时</span></span><br><span class="line">                <span class="keyword">if</span> (Rear-&gt;link-&gt;coef + c) <span class="comment">//系数相加不为0时</span></span><br><span class="line">                    Rear-&gt;link-&gt;coef += c;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">//系数相加为0时</span></span><br><span class="line">                    t = Rear-&gt;link;</span><br><span class="line">                    Rear-&gt;link = t-&gt;link;</span><br><span class="line">                    <span class="built_in">free</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//rear下一项指数和插入项指数不相等时，新建结点插入</span></span><br><span class="line">                t = (Polynomial)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct PolyNode));</span><br><span class="line">                t-&gt;coef = c;</span><br><span class="line">                t-&gt;expon = e;</span><br><span class="line">                t-&gt;link = Rear-&gt;link;</span><br><span class="line">                Rear-&gt;link = t;</span><br><span class="line">                Rear = Rear-&gt;link;</span><br><span class="line">            &#125;</span><br><span class="line">            t2 = t2-&gt;link; <span class="comment">//历遍t2</span></span><br><span class="line">        &#125;</span><br><span class="line">        t1 = t1-&gt;link;<span class="comment">//逐个历遍t1第二项之后</span></span><br><span class="line">    &#125;</span><br><span class="line">    t2 = P; P = P-&gt;link; <span class="built_in">free</span>(t2);</span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPoly</span><span class="params">(Polynomial P)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!P)&#123;<span class="built_in">printf</span>(<span class="string">&quot;0 0\n&quot;</span>); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">while</span> (P)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="comment">//调整输出格式，使第一项输出头部无空格</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);<span class="comment">//使第二项输出头部、第三项输出头部...有空格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,P-&gt;coef, P-&gt;expon);</span><br><span class="line">        P = P-&gt;link; <span class="comment">//输出下一个结点，我找了它接近两个小时，写的时候漏了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Polynomial P1, P2, PP, PS;</span><br><span class="line">    P1 = ReadPoly(); <span class="comment">//读取</span></span><br><span class="line">    P2 = ReadPoly();</span><br><span class="line">    </span><br><span class="line">    PP = Mult(P1, P2); <span class="comment">//乘法</span></span><br><span class="line">    PS = Add(P1,P2); <span class="comment">//加法</span></span><br><span class="line">    </span><br><span class="line">    PrintPoly(PP); <span class="comment">//打印</span></span><br><span class="line">    PrintPoly(PS);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<br>1、<code>P(front)</code>作为<strong>头部空结点指针</strong>，最后<code>P(front)</code>要用<code>t</code>配合<code>free</code>函数<strong>释放</strong>。</p>
<p>2、<code>rear = P(front)</code> 一开始是<strong>空结点指针</strong>，但最后会作为<strong>尾部结点指针</strong>，所以最终<code>rear-&gt;link == NULL</code></p>
<p>3、设置<code>flag</code>调整输出格式。</p>
<h2 id="02-线性结构3-Reversing-Linked-List-25-分"><a href="#02-线性结构3-Reversing-Linked-List-25-分" class="headerlink" title="02-线性结构3 Reversing Linked List (25 分)"></a>02-线性结构3 Reversing Linked List (25 分)</h2><p>Given a constant <em>K</em> and a singly linked list <em>L</em>, you are supposed to reverse the links of every <em>K</em> elements on <em>L</em>. For example, given <em>L</em> being 1→2→3→4→5→6, if <em>K</em>=3, then you must output 3→2→1→6→5→4; if <em>K</em>=4, you must output 4→3→2→1→5→6.</p>
<p>翻译：给定一个常数K和一个单链链表L，你应该把L上每个K元素的链结颠倒。例如，给定L为1→2→3→4→5→6，如果K=3，那么你必须输出3→2→1→6→5→4；如果K=4，你必须输出4→3→2→1→5→6。</p>
<p><strong>Input Specification:</strong></p>
<p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <em>N</em> (≤105) which is the total number of nodes, and a positive <em>K</em> (≤<em>N</em>) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p>
<p>翻译：每个输入文件包含一个测试用例。对于每种情况，第一行包含第一个节点的地址、节点总数的正N（&lt;105）和要反转的子列表的长度的正K（&lt;N）。节点的地址是一个5位非负整数，空值用-1表示。</p>
<p>Then <em>N</em> lines follow, each describes a node in the format:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure>

<p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p>
<p><strong>Output Specification:</strong></p>
<p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<p><strong>Sample Input:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00100 6 4</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>

<p><strong>Sample Output:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000 4 33218</span><br><span class="line">33218 3 12309</span><br><span class="line">12309 2 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 -1</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>

<p><strong>AC code:</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100005</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Data[MaxSize];</span><br><span class="line">	<span class="keyword">int</span> Next[MaxSize]; </span><br><span class="line">	<span class="keyword">int</span> List[MaxSize]; <span class="comment">//List[]用来存放当前结点的地址，其索引是序号0 ~ 100005</span></span><br><span class="line">	<span class="keyword">int</span> FirstAdd, N, K, i ,j, t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;FirstAdd, &amp;N, &amp;K);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在Data[]中存放数值，在Next[]中存放下一个结点地址</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> tmpAdd, tmpData, tmpNext;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;tmpAdd, &amp;tmpData, &amp;tmpNext);</span><br><span class="line">		Data[tmpAdd] = tmpData; <span class="comment">//Date[]用来存放数值，其索引是当前结点地址</span></span><br><span class="line">		Next[tmpAdd] = tmpNext; <span class="comment">//Next[]用来存放下个结点的地址，其索引是当前结点地址</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在List中存放当前结点的地址</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;   <span class="comment">//累计有效结点数</span></span><br><span class="line">	<span class="keyword">while</span>(FirstAdd != <span class="number">-1</span>)&#123;   <span class="comment">//当尾结点为 -1 时结束 </span></span><br><span class="line">		List[count++] = FirstAdd; </span><br><span class="line">		FirstAdd = Next[FirstAdd];  <span class="comment">//将下个结点的地址赋值给FistAddress</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//按区间反转</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count-count%K; i += K)&#123;  <span class="comment">//每 K个结点一个区间 </span></span><br><span class="line">	<span class="comment">//每个区间内，首、尾结点互换，次首、次尾结点互换结点，以此类推</span></span><br><span class="line">	<span class="comment">//奇数区间到最后自己和自己互换，没有影响</span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; K/<span class="number">2</span>; j++)&#123;  </span><br><span class="line">			t = List[i+j];</span><br><span class="line">			List[i+j] = List[i+K-j<span class="number">-1</span>];</span><br><span class="line">			List[i+K-j<span class="number">-1</span>] = t; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count<span class="number">-1</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,List[i], Data[List[i]], List[i+<span class="number">1</span>]);</span><br><span class="line">	<span class="comment">//-1按&#x27;%05%&#x27;的格式输出为-0001，不符合要求，所以我们单独输出最后一个结点</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1\n&quot;</span>, List[count<span class="number">-1</span>], Data[List[count<span class="number">-1</span>]]); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：用<strong>三个数组的方式模拟链表</strong>，分别存放当前地址、数值、下一个地址。实际上用结构数组、链表的方法也可以，但三个数组易于理解。</p>
<p>样例图示：</p>
<p><img src="https://s3.bmp.ovh/imgs/2021/11/6952cdeb331ca65c.jpg"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liyuanyue2017/article/details/83269991">参考链接1</a>；<a target="_blank" rel="noopener" href="https://blog.csdn.net/tiao_god/article/details/105018843">参考链接2</a></p>
<h2 id="03-树1-树的同构-25-分"><a href="#03-树1-树的同构-25-分" class="headerlink" title="03-树1 树的同构 (25 分)"></a><strong>03-树1 树的同构 (25 分)</strong></h2><p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p>
<p><img src="https://s3.bmp.ovh/imgs/2021/10/aba50c13696cb518.png"></p>
<p>现给定两棵树，请你判断它们是否是同构的。</p>
<p><strong>输入格式</strong>:</p>
<p>输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数<em>N</em> (≤10)，即该树的结点数（此时假设结点从0到<em>N</em>−1编号）；随后<em>N</em>行，第<em>i</em>行对应编号第<em>i</em>个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。</p>
<p><strong>输出格式</strong>:</p>
<p>如果两棵树是同构的，输出“Yes”，否则输出“No”。</p>
<p><strong>输入样例1（对应图1）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">A 1 2</span><br><span class="line">B 3 4</span><br><span class="line">C 5 -</span><br><span class="line">D - -</span><br><span class="line">E 6 -</span><br><span class="line">G 7 -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line">8</span><br><span class="line">G - 4</span><br><span class="line">B 7 6</span><br><span class="line">F - -</span><br><span class="line">A 5 1</span><br><span class="line">H - -</span><br><span class="line">C 0 -</span><br><span class="line">D - -</span><br><span class="line">E 2 -</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>

<p><strong>输出样例1</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>

<p><strong>输入样例2（对应图2）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">B 5 7</span><br><span class="line">F - -</span><br><span class="line">A 0 3</span><br><span class="line">C 6 -</span><br><span class="line">H - -</span><br><span class="line">D - -</span><br><span class="line">G 4 -</span><br><span class="line">E 1 -</span><br><span class="line">8</span><br><span class="line">D 6 -</span><br><span class="line">B 5 -</span><br><span class="line">E - -</span><br><span class="line">H - -</span><br><span class="line">C 0 2</span><br><span class="line">G - 3</span><br><span class="line">F - -</span><br><span class="line">A 1 4</span><br></pre></td></tr></table></figure>

<p><strong>输出样例2</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure>

<p><strong>答案</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxTree 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tree int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Null -1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">  ElementType Element;</span><br><span class="line">  Tree Left;</span><br><span class="line">  Tree Right;</span><br><span class="line">&#125; T1[MaxTree], T2[MaxTree];</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">BuildTree</span> <span class="params">( struct TreeNode T[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Isomorphic</span><span class="params">(Tree R1,Tree R2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Tree R1, R2;</span><br><span class="line">  R1 = BuildTree(T1);</span><br><span class="line">  R2 = BuildTree(T2);</span><br><span class="line">  <span class="keyword">if</span> (Isomorphic(R1, R2)) </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">BuildTree</span><span class="params">( struct TreeNode T[] )</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, i;</span><br><span class="line">  <span class="keyword">int</span> check[MaxTree];</span><br><span class="line">  Tree Root = Null; <span class="comment">//Root set Null, because line 34 and line 55, if N = 0, return Null</span></span><br><span class="line">  ElementType cl, cr;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">  <span class="keyword">if</span> (N) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) check[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;\n%c %c %c&quot;</span>, &amp;T[i].Element, &amp;cl, &amp;cr);</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="string">&#x27;-&#x27;</span>) &#123; <span class="comment">// four ‘if’ are at the same level</span></span><br><span class="line">      T[i].Left = cl - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      check[T[i].Left] = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">if</span> (cl == <span class="string">&#x27;-&#x27;</span>) </span><br><span class="line">      T[i].Left = Null;</span><br><span class="line">    <span class="keyword">if</span> (cr != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">      T[i].Right = cr-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      check[T[i].Right] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cr == <span class="string">&#x27;-&#x27;</span>) </span><br><span class="line">      T[i].Right = Null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">      <span class="keyword">if</span> (!check[i]) <span class="keyword">break</span>;</span><br><span class="line">    Root = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Isomorphic</span> <span class="params">( Tree R1, Tree R2 )</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (R1==Null )&amp;&amp; (R2==Null) ) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">/* both empty */</span></span><br><span class="line">  <span class="keyword">if</span> ( ((R1==Null)&amp;&amp;(R2!=Null)) || ((R1!=Null)&amp;&amp;(R2==Null)) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* one of them is empty */</span></span><br><span class="line">  <span class="keyword">if</span> ( T1[R1].Element != T2[R2].Element )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* roots Element are different */</span></span><br><span class="line">  <span class="keyword">if</span> ( ( T1[R1].Left == Null )&amp;&amp;( T2[R2].Left == Null ) )</span><br><span class="line">    <span class="keyword">return</span> Isomorphic( T1[R1].Right, T2[R2].Right );<span class="comment">/* both have no left sontree */</span></span><br><span class="line">  <span class="keyword">if</span> ( ((T1[R1].Left!=Null)&amp;&amp;(T2[R2].Left!=Null)) &amp;&amp; ((T1[T1[R1].Left].Element)==(T2[T2[R2].Left].Element)) )</span><br><span class="line">  <span class="comment">/* no need to swap the left and the right */</span></span><br><span class="line">  <span class="comment">/*If the left son of both trees is not empty and the Element is the same, recurse on the left son*/</span></span><br><span class="line">  <span class="comment">/* 如果两棵树左儿子都不为空并且元素还是一样的，对左儿子进行递归*/</span></span><br><span class="line">    <span class="keyword">return</span> ( Isomorphic( T1[R1].Left, T2[R2].Left ) &amp;&amp; Isomorphic( T1[R1].Right, T2[R2].Right ) );</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">/* need to swap the left and the right */</span></span><br><span class="line">  <span class="comment">/*If two trees have different left sons (one is empty and neither is empty or neither is empty), </span></span><br><span class="line"><span class="comment">  then determine whether the left (right) son of the first tree is isomorphic to the right (left) son of the second tree*/</span></span><br><span class="line">  <span class="comment">/* 如果两棵树左儿子（一个空一个不空或者都不空）并且元素不一样，</span></span><br><span class="line"><span class="comment">  那么判断第一棵树的左（右）儿子是否跟第二棵树的右（左）儿子同构 */</span></span><br><span class="line">    <span class="keyword">return</span> ( Isomorphic( T1[R1].Left, T2[R2].Right) &amp;&amp; Isomorphic( T1[R1].Right, T2[R2].Left ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>判断cl、cr是否为横杠<code>-</code>时，四个if语句是处于同一水平同时判断的。</li>
<li>初始化root为Null可以使得当N为空时，能够返回Null(-1)。</li>
<li>判断是否“同构”时，需要多方考虑。也要经常调用递归。</li>
</ul>
<h2 id="04-树4-是否同一棵二叉搜索树-25-分"><a href="#04-树4-是否同一棵二叉搜索树-25-分" class="headerlink" title="04-树4 是否同一棵二叉搜索树 (25 分)"></a>04-树4 是否同一棵二叉搜索树 (25 分)</h2><p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。</p>
<p><strong>输入格式:</strong></p>
<p>输入包含若干组测试数据。每组数据的第1行给出两个正整数<em>N</em> (≤10)和<em>L</em>，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出<em>N</em>个以空格分隔的正整数，作为初始插入序列。随后<em>L</em>行，每行给出<em>N</em>个插入的元素，属于<em>L</em>个需要检查的序列。</p>
<p>简单起见，我们保证每个插入序列都是1到<em>N</em>的一个排列。当读到<em>N</em>为0时，标志输入结束，这组数据不要处理。</p>
<p><strong>输出格式:</strong></p>
<p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p>
<p><strong>输入样例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">3 1 4 2</span><br><span class="line">3 4 1 2</span><br><span class="line">3 2 4 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>

<p><strong>输出样例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>

<p><strong>AC code：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  Tree Left, Right;</span><br><span class="line">  <span class="keyword">int</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">( <span class="keyword">int</span> N )</span></span>;</span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">( Tree T, <span class="keyword">int</span> V )</span></span>;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">( <span class="keyword">int</span> V )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span> <span class="params">( Tree T, <span class="keyword">int</span> V )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">( Tree T, <span class="keyword">int</span> N )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span> <span class="params">( Tree T )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span> <span class="params">( Tree T )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> N, L, i;</span><br><span class="line">  Tree T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">  <span class="keyword">while</span> (N) &#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;L);</span><br><span class="line">  T = MakeTree(N);</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;L; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Judge(T, N))<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    ResetT(T); <span class="comment">/*清除T中的标记flag*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  FreeTree(T);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">( <span class="keyword">int</span> N )</span></span>&#123; </span><br><span class="line">  Tree T;</span><br><span class="line">  <span class="keyword">int</span> i, V;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;V);</span><br><span class="line">  T = NewNode(V);</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;N; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;V);</span><br><span class="line">    T = Insert(T, V);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">( Tree T, <span class="keyword">int</span> V )</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !T ) T = NewNode(V);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( V&gt;T-&gt;v )</span><br><span class="line">      T-&gt;Right = Insert( T-&gt;Right, V );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      T-&gt;Left = Insert( T-&gt;Left, V );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">( <span class="keyword">int</span> V )</span></span>&#123; </span><br><span class="line">  Tree T = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">  T-&gt;v = V;</span><br><span class="line">  T-&gt;Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">  T-&gt;flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span> <span class="params">( Tree T, <span class="keyword">int</span> V )</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( T-&gt;flag ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( V&lt;T-&gt;v ) <span class="keyword">return</span> check(T-&gt;Left, V);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( V&gt;T-&gt;v ) <span class="keyword">return</span> check(T-&gt;Right, V);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( V==T-&gt;v ) &#123;</span><br><span class="line">      T-&gt;flag = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">( Tree T, <span class="keyword">int</span> N )</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, V, flag = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">/* flag: 0代表目前还一致，1代表已经不一致*/</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;V);</span><br><span class="line">  <span class="keyword">if</span> ( V!=T-&gt;v ) flag = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> T-&gt;flag = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;N; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;V);</span><br><span class="line">    <span class="keyword">if</span> ( (!flag) &amp;&amp; (!check(T, V)) ) flag = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span> <span class="params">( Tree T )</span> </span>&#123; <span class="comment">/* 清除T中各结点的flag标记 */</span></span><br><span class="line">  <span class="keyword">if</span> (T-&gt;Left) ResetT(T-&gt;Left);</span><br><span class="line">  <span class="keyword">if</span> (T-&gt;Right) ResetT(T-&gt;Right);</span><br><span class="line">  T-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span> <span class="params">( Tree T )</span> </span>&#123; <span class="comment">/* 释放T的空间 */</span></span><br><span class="line">  <span class="keyword">if</span> (T-&gt;Left) FreeTree(T-&gt;Left);</span><br><span class="line">  <span class="keyword">if</span> (T-&gt;Right) FreeTree(T-&gt;Right);</span><br><span class="line">  <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：先丢个链接，何钦铭老师的思路。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JW411i731?p=48">b站参考链接</a></p>
<h2 id="05-树7-堆中的路径-25-分"><a href="#05-树7-堆中的路径-25-分" class="headerlink" title="05-树7 堆中的路径 (25 分)"></a>05-树7 堆中的路径 (25 分)</h2><p>将一系列给定数字插入一个初始为空的小顶堆<code>H[]</code>。随后对任意给定的下标<code>i</code>，打印从<code>H[i]</code>到根结点的路径。</p>
<p><strong>输入格式:</strong></p>
<p>每组测试第1行包含2个正整数<em>N</em>和<em>M</em>(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的<em>N</em>个要被插入一个初始为空的小顶堆的整数。最后一行给出<em>M</em>个下标。</p>
<p><strong>输出格式:</strong></p>
<p>对输入中给出的每个下标<code>i</code>，在一行中输出从<code>H[i]</code>到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p>
<p><strong>输入样例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">46 23 26 24 10</span><br><span class="line">5 4 3</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>

<p><strong>输出样例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">24 23 10</span><br><span class="line">46 23 10</span><br><span class="line">26 10</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure>

<p>AC code：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINH -10001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> H[MAXN], size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span> <span class="params">()</span></span>&#123;</span><br><span class="line"> size = <span class="number">0</span>;</span><br><span class="line"> H[<span class="number">0</span>] = MINH;</span><br><span class="line"> <span class="comment">/*设置“岗哨”*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">( <span class="keyword">int</span> X )</span></span>&#123;</span><br><span class="line">  <span class="comment">/* 将X插入H。这里省略检查堆是否已满的代码 */</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = ++size; H[i/<span class="number">2</span>] &gt; X; i /= <span class="number">2</span>)</span><br><span class="line">    H[i] = H[i/<span class="number">2</span>];</span><br><span class="line">  H[i] = X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m, x, i, j;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  Create(); <span class="comment">/* 堆初始化 */</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123; <span class="comment">/*以逐个插入方式建堆 */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    Insert(x);</span><br><span class="line">&#125; </span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, H[j]);</span><br><span class="line">    <span class="keyword">while</span> (j&gt;<span class="number">1</span>) &#123; <span class="comment">/*沿根方向输出各结点*/</span></span><br><span class="line">      j /= <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, H[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：先丢个链接，何钦铭老师的思路。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JW411i731?p=64">b站参考链接</a></p>
<h2 id="05-树8-File-Transfer-25-分"><a href="#05-树8-File-Transfer-25-分" class="headerlink" title="05-树8 File Transfer (25 分)"></a>05-树8 File Transfer (25 分)</h2><p>We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?</p>
<p><strong>Input Specification:</strong></p>
<p>Each input file contains one test case. For each test case, the first line contains <em>N</em> (2≤<em>N</em>≤104), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and <em>N</em>. Then in the following lines, the input is given in the format:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I c1 c2  </span><br></pre></td></tr></table></figure>

<p>where <code>I</code> stands for inputting a connection between <code>c1</code> and <code>c2</code>; or</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C c1 c2    </span><br></pre></td></tr></table></figure>

<p>where <code>C</code> stands for checking if it is possible to transfer files between <code>c1</code> and <code>c2</code>; or</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S</span><br></pre></td></tr></table></figure>

<p>where <code>S</code> stands for stopping this case.</p>
<p><strong>Output Specification:</strong></p>
<p>For each <code>C</code> case, print in one line the word “yes” or “no” if it is possible or impossible to transfer files between <code>c1</code> and <code>c2</code>, respectively. At the end of each case, print in one line “The network is connected.” if there is a path between any pair of computers; or “There are <code>k</code> components.” where <code>k</code> is the number of connected components in this network.</p>
<p><strong>Sample Input 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">C 3 2</span><br><span class="line">I 3 2</span><br><span class="line">C 1 5</span><br><span class="line">I 4 5</span><br><span class="line">I 2 4</span><br><span class="line">C 3 5</span><br><span class="line">S</span><br></pre></td></tr></table></figure>

<p><strong>Sample Output 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">There are 2 components.</span><br></pre></td></tr></table></figure>

<p><strong>Sample Input 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">C 3 2</span><br><span class="line">I 3 2</span><br><span class="line">C 1 5</span><br><span class="line">I 4 5</span><br><span class="line">I 2 4</span><br><span class="line">C 3 5</span><br><span class="line">I 1 3</span><br><span class="line">C 1 5</span><br><span class="line">S</span><br></pre></td></tr></table></figure>

<p><strong>Sample Output 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">The network is connected.</span><br></pre></td></tr></table></figure>

<p><strong>AC code：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType; <span class="comment">/*默认元素可以用非负整数表示*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SetName; <span class="comment">/*默认用根结点的下标作为集合名称*/</span></span><br><span class="line"><span class="keyword">typedef</span> ElementType SetType[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialization</span><span class="params">( SetType S, <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input_connection</span><span class="params">( SetType S )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Check_connection</span><span class="params">( SetType S )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Check_network</span><span class="params">( SetType S, <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">( SetType S, SetName Root1, SetName Root2 )</span></span>;</span><br><span class="line"><span class="function">SetName <span class="title">Find</span><span class="params">( SetType S, ElementType X )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialization</span><span class="params">( SetType S, <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    S[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input_connection</span><span class="params">( SetType S )</span></span>&#123;</span><br><span class="line">  ElementType u, v;</span><br><span class="line">  SetName Root1, Root2;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d\n&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">  Root1 = Find(S, u<span class="number">-1</span>);</span><br><span class="line">  Root2 = Find(S, v<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( Root1 != Root2 )</span><br><span class="line">    Union( S, Root1, Root2 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Check_connection</span><span class="params">( SetType S )</span></span>&#123; </span><br><span class="line">  ElementType u, v;</span><br><span class="line">  SetName Root1, Root2;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d\n&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">  Root1 = Find(S, u<span class="number">-1</span>);</span><br><span class="line">  Root2 = Find(S, v<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( Root1 == Root2 )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;yes\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Check_network</span><span class="params">( SetType S, <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( S[i] &lt; <span class="number">0</span> ) counter++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( counter == <span class="number">1</span> )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The network is connected.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;There are %d components.\n&quot;</span>, counter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">( SetType S, SetName Root1, SetName Root2 )</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( S[Root2] &lt; S[Root1] )&#123;</span><br><span class="line">    S[Root2] += S[Root1];</span><br><span class="line">    S[Root1] = Root2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    S[Root1] += S[Root2];</span><br><span class="line">    S[Root2] = Root1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SetName <span class="title">Find</span><span class="params">( SetType S, ElementType X )</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( S[X] &lt; <span class="number">0</span> ) <span class="comment">/* 找到集合的根 */</span></span><br><span class="line">    <span class="keyword">return</span> X;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> S[X] = Find( S, S[X] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">  SetType S;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">char</span> in;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;n);</span><br><span class="line">  Initialization( S, n );</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;in);</span><br><span class="line">    <span class="keyword">switch</span> (in) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: Input_connection( S ); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: Check_connection( S ); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: Check_network( S, n ); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> ( in != <span class="string">&#x27;S&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：先丢个链接，陈越老师的思路。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JW411i731?p=60">b站参考链接</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/13/CSAPP-AttackLab/" rel="prev" title="AttackLab">
      <i class="fa fa-chevron-left"></i> AttackLab
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/04/notebook/" rel="next" title="个人随笔">
      个人随笔 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Function"><span class="nav-number">1.</span> <span class="nav-text">Function</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01-%E5%A4%8D%E6%9D%82%E5%BA%A63-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-20-%E5%88%86"><span class="nav-number">1.1.</span> <span class="nav-text">01-复杂度3 二分查找 (20 分)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#04-%E6%A0%917-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%E9%9B%86-30-%E5%88%86"><span class="nav-number">1.2.</span> <span class="nav-text">04-树7 二叉搜索树的操作集 (30 分)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Programming"><span class="nav-number">2.</span> <span class="nav-text">Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01-%E5%A4%8D%E6%9D%82%E5%BA%A61-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98-20-%E5%88%86"><span class="nav-number">2.1.</span> <span class="nav-text">01-复杂度1 最大子列和问题 (20 分)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#01-%E5%A4%8D%E6%9D%82%E5%BA%A62-Maximum-Subsequence-Sum-25-%E5%88%86"><span class="nav-number">2.2.</span> <span class="nav-text">01-复杂度2 Maximum Subsequence Sum (25 分)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E4%B8%8E%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97-20-%E5%88%86"><span class="nav-number">2.3.</span> <span class="nav-text">02-线性结构2 一元多项式的乘法与加法运算 (20 分)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-Reversing-Linked-List-25-%E5%88%86"><span class="nav-number">2.4.</span> <span class="nav-text">02-线性结构3 Reversing Linked List (25 分)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#03-%E6%A0%911-%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84-25-%E5%88%86"><span class="nav-number">2.5.</span> <span class="nav-text">03-树1 树的同构 (25 分)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#04-%E6%A0%914-%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-25-%E5%88%86"><span class="nav-number">2.6.</span> <span class="nav-text">04-树4 是否同一棵二叉搜索树 (25 分)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#05-%E6%A0%917-%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84-25-%E5%88%86"><span class="nav-number">2.7.</span> <span class="nav-text">05-树7 堆中的路径 (25 分)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#05-%E6%A0%918-File-Transfer-25-%E5%88%86"><span class="nav-number">2.8.</span> <span class="nav-text">05-树8 File Transfer (25 分)</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Huang Jinhong</p>
  <div class="site-description" itemprop="description">“我们来到这世上是为的是看太阳”</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/duilec" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;duilec" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/duile" title="博客园 → https:&#x2F;&#x2F;www.cnblogs.com&#x2F;duile" rel="noopener" target="_blank"><i class="fab fa-cnblog fa-fw"></i>博客园</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Huang Jinhong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"fflLscOo9DyB8Fx8ubGOzkl5-MdYXbMMI","app_key":"RrGHmVsgcizeqfrfsKcX4Sko","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'fflLscOo9DyB8Fx8ubGOzkl5-MdYXbMMI',
      appKey     : 'RrGHmVsgcizeqfrfsKcX4Sko',
      placeholder: "发表评论",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
