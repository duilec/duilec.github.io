<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="开始日期：22.4.19 操作系统：Ubuntu20.0.4 Link：Lab COW">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab COW">
<meta property="og:url" content="http://example.com/2022/04/20/MIT6.S081-Lab%20COW/index.html">
<meta property="og:site_name" content="Memory Dot">
<meta property="og:description" content="开始日期：22.4.19 操作系统：Ubuntu20.0.4 Link：Lab COW">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/04/22/gM6FmvVWfst4Axn.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/22/OsWYrFyQGhR6wAc.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/22/ORa9LFx4BJ7QEGm.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/22/egpsN5WdBn83ufP.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/22/Dbej5UMxwqTJnGz.png">
<meta property="article:published_time" content="2022-04-20T05:12:39.000Z">
<meta property="article:modified_time" content="2022-05-29T07:34:40.574Z">
<meta property="article:author" content="Huang Jinhong">
<meta property="article:tag" content="c">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="xv6">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/04/22/gM6FmvVWfst4Axn.png">

<link rel="canonical" href="http://example.com/2022/04/20/MIT6.S081-Lab%20COW/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Lab COW | Memory Dot</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Memory Dot</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/20/MIT6.S081-Lab%20COW/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Jinhong">
      <meta itemprop="description" content="“我们来到这世上是为的是看太阳”">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Memory Dot">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Lab COW
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-20 13:12:39" itemprop="dateCreated datePublished" datetime="2022-04-20T13:12:39+08:00">2022-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-29 15:34:40" itemprop="dateModified" datetime="2022-05-29T15:34:40+08:00">2022-05-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-S081-Lab/" itemprop="url" rel="index"><span itemprop="name">MIT6.S081-Lab</span></a>
                </span>
            </span>

          
            <span id="/2022/04/20/MIT6.S081-Lab%20COW/" class="post-meta-item leancloud_visitors" data-flag-title="Lab COW" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/20/MIT6.S081-Lab%20COW/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/20/MIT6.S081-Lab%20COW/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>开始日期：<em>22.4.19</em></p>
<p>操作系统：<strong>Ubuntu20.0.4</strong></p>
<p>Link：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2021/labs/cow.html">Lab COW</a></p>
<span id="more"></span> 

<h1 id="Lab-COW"><a href="#Lab-COW" class="headerlink" title="Lab COW"></a>Lab COW</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><h3 id="Virtual-address"><a href="#Virtual-address" class="headerlink" title="Virtual address"></a>Virtual address</h3><ul>
<li><p>关于虚拟地址的概念，一直不是很清晰，<em>book-riscv-rev2</em>中给出的概念是：虚拟地址是用来给xv6操作的地址</p>
<blockquote>
<p>P26</p>
<p>The RISC-V page table translates (or “maps”) a virtual address (the address that an RISC-V instruction manipulates) to a physical address (an address that the CPU chip sends to main memory).</p>
</blockquote>
</li>
<li><p>事实上，这个说法没有错，但<strong>虚拟地址是怎么来的却没有说清楚</strong>，于是我翻阅了<em>Modern operating systems</em>和<em>Computer Systems. A Programmer’s Perspective 3rd Edition</em>，查询了虚拟内存的章节，里面提到：</p>
<blockquote>
<p><em>Modern operating systems</em>P195</p>
<p>…<strong>Addresses can be generated using indexing, base registers, segment registers, and other ways</strong>.</p>
<p><strong>These program-generated addresses are called virtual addresses</strong> and form the virtual address space.</p>
<p>On computers without virtual memory, the virtual address is put directly onto the memory bus and causes the physical memory word with the same address to be read or written. When virtual memory is used, the virtual addresses do not go directly to the memory bus. Instead, they go to an MMU (Memory Management Unit) that maps the virtual addresses onto the physical memory addresses, as illustrated in Fig. 3-8.</p>
<p><img src="https://s2.loli.net/2022/04/22/gM6FmvVWfst4Axn.png"></p>
<p><em>Computer Systems. A Programmer’s Perspective 3rd Edition</em></p>
<p>With virtual addressing, <strong>the CPU accesses main memory by generating a virtual address (VA), which is converted to the appropriate physical address before being sent to main memory.</strong></p>
<p><img src="https://s2.loli.net/2022/04/22/OsWYrFyQGhR6wAc.png"></p>
</blockquote>
<ul>
<li>综合来看， <strong>程序调用cpu使用索引、基址寄存器、段寄存器或其它方式产生的地址就称为虚拟地址，它们的集合构成了一个虚拟地址空间</strong><br>使用虚拟地址的方式，就是程序在cpu里跑的时候，cpu会生成虚拟地址，再转换为物理地址，发送到物理内存，找到一样的物理地址，从里面拿出数据来。</li>
</ul>
</li>
<li><p>在我们的xv6，所谓<strong>MMU</strong>，就是我们的对用户程序虚拟空间采用三级页表，对内核虚拟空间采用直接映射</p>
</li>
<li><p>从概念上想，一个CPU产生一个虚拟空间后，xv6会使用<code>stap</code>切换页表，<strong>在相同的虚拟空间里使用不同的页表，虚拟空间指向的物理内存就不一样了</strong></p>
</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="http://xv6.dgs.zone/labs/answers/lab6.html">Lab6: Copy-on-Write Fork for xv6</a></li>
</ul>
<h2 id="Copy-on-Write"><a href="#Copy-on-Write" class="headerlink" title="Copy-on-Write"></a>Copy-on-Write</h2><ul>
<li>认真看hint和plan，大部分思路都提供，一部分思路需要自己多尝试或者参考= =</li>
</ul>
<ul>
<li><p>添加引用计数<code>ref_count</code></p>
<ul>
<li><p>我们分页时，只是在物理内存这一块分页，也就是<code>KERBASE ~ PHYSTOP</code></p>
</li>
<li><p>为什么要用<code>lock</code>，因为<code>ref_count</code>是共享的，容易出现覆盖，考虑如下例子</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://xv6.dgs.zone/labs/answers/lab6.html">Lab6: Copy-on-Write Fork for xv6</a></p>
<p>这里使用自旋锁是考虑到这种情况：进程P1和P2共用内存M，M引用计数为2，此时CPU1要执行<code>fork</code>产生P1的子进程，CPU2要终止P2，那么假设两个CPU同时读取引用计数为2，执行完成后CPU1中保存的引用计数为3，CPU2保存的计数为1，那么后赋值的语句会覆盖掉先赋值的语句，从而产生错误</p>
</blockquote>
</li>
<li><p>注意： <code>ref_count</code>是全局变量，会自动初始化为<code>0</code></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/kalloc.c */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">  uint8 ref_count[(PHYSTOP - KERNBASE) / PGSIZE]; </span><br><span class="line">  <span class="comment">// just use KERBASE ~ PHYSTOP memory(128M)</span></span><br><span class="line">  <span class="comment">// 128*1024*1024 / 4096 = 32768 pages</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    </p>
<ul>
<li><p><code>ref_count</code>增加<code>1</code></p>
<ul>
<li>记得要添加到声明到<code>defs.h</code>中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/kalloc.c */</span></span><br><span class="line"><span class="comment">// Increment a page&#x27;s reference count when fork causes a child to share the page, </span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">increment_refcount</span><span class="params">(uint64 pa)</span></span>&#123;</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  kmem.ref_count[(pa - KERNBASE) / PGSIZE]++;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>ref_count</code>减少<code>1</code></p>
<ul>
<li>每次取消对某个物理内存页的引用，最终都会调用到<code>kfree()</code>，因此<code>ref_count</code>减少<code>1</code>在<code>kfree()</code>实现比较合理。同时，当<code>ref_count</code>减少到<code>0</code>时，即可释放这一物理页。</li>
<li>要先在<code>freerange()</code>中，将全部<code>ref_count</code>初始化为<code>1</code>，因为调用<code>kfree()</code>时，会自动减<code>1</code>，要抵消这个自动减<code>1</code>。我们希望空闲链表组建之后，在未分配之前，所有物理页面的<code>ref_count</code>全为<code>0</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/kalloc.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">freerange</span><span class="params">(<span class="keyword">void</span> *pa_start, <span class="keyword">void</span> *pa_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  p = (<span class="keyword">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="keyword">char</span>*)pa_end; p += PGSIZE)&#123;</span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    kmem.ref_count[((uint64)p - KERNBASE) / PGSIZE] = <span class="number">1</span>;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    kfree(p);    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// kfree() should only place a page back on the free list</span></span><br><span class="line">  <span class="comment">// if its reference count is zero.</span></span><br><span class="line">  <span class="comment">// decrement a page&#x27;s count each time any process drops the page from its page table.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> if drops the page, we must call kfree() finally</span></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">if</span>(--kmem.ref_count[((uint64)pa - KERNBASE) / PGSIZE] == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">    <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    r = (struct run*)pa;</span><br><span class="line">    </span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分配<code>kalloc</code>一次物理页，就将这个物理页<code>ref_count</code>设置为<code>1</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/kalloc.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    <span class="comment">// Set a page&#x27;s reference count to one when kalloc() allocates it.  </span></span><br><span class="line">    kmem.ref_count[((uint64)r - KERNBASE) / PGSIZE] = <span class="number">1</span>;</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>得到物理页的<code>ref_count</code></p>
<ul>
<li><code>ref_count</code>仅限于在 <code>kernel/kalloc.c</code>中使用，其它地方无法调用得到</li>
<li>记得要添加到声明到<code>defs.h</code>中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">get_refcount</span><span class="params">(uint64 pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> kmem.ref_count[(pa - KERNBASE) / PGSIZE];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>添加<code>PTE_COW</code>，标识这个PTE是<em>copy on write</em>（写时复制）的物理页</p>
<ul>
<li><em>riscv-privileged</em>，P77，我们使用第8位当作标识位<br><img src="https://s2.loli.net/2022/04/22/ORa9LFx4BJ7QEGm.png"></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_COW (1L <span class="meta-string">&lt;&lt; 8) // 1 -&gt;</span> COW page</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>修改<code>uvmcopy</code></p>
<ul>
<li>调用<code>uvmcopy</code>时，如果当前页面可以写，那就将其置为不可写，同时将其标识为<em>cowpage</em>。</li>
<li>最终我们不再分配一个新的物理页，而是直接映射到旧的物理页</li>
<li>当要写这个<strong>不可写但为cowpage的页面</strong>时，启动中断<em>page fault</em> ，此时我们才分配新的物理页</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/vm.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">uvmcopy</span><span class="params">(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Increment a page&#x27;s reference count when fork causes a child to share the page, </span></span><br><span class="line">    increment_refcount(PGROUNDDOWN(pa));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* just clear PTE_W for page with PTE_W */</span></span><br><span class="line">    <span class="keyword">if</span> (*pte &amp; PTE_W)&#123;</span><br><span class="line">      <span class="comment">/* clear PTE_W */</span></span><br><span class="line">      *pte &amp;= (~PTE_W);</span><br><span class="line">      <span class="comment">/* set PTE_COW */</span></span><br><span class="line">      *pte |= PTE_COW;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span>(mappages(<span class="keyword">new</span>, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>usertrap</code>，我们需要两个辅助函数</p>
<ul>
<li><p><code>r_scause() == 15</code>的是我们要处理的<code>store page fault</code></p>
<ul>
<li>store是将数据从寄存器写到内存当中，我们就是要将一些数据从寄存器写到物理页内存当中</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/22/egpsN5WdBn83ufP.png"></p>
</li>
<li><p><code>stval()</code>的值此时是发生错误的虚拟地址，即<code>fault_va</code></p>
<blockquote>
<p> <em>riscv-privileged</em> P67</p>
<p>When a hardware breakpoint is triggered, or an instruction, load, or store address-misaligned, access-fault, or page-fault exception occurs, <strong>stval is written with the faulting virtual address</strong>.</p>
</blockquote>
</li>
<li><p>如果遇到<code>fault_va</code>超过<code>p -&gt; sz</code>，说明地址错误了，无法处理</p>
<ul>
<li>这一点是<code>usertests</code>测试的</li>
</ul>
</li>
<li><p><code>is_cowpage</code>用来判断该页面是不是<em>cowpage</em></p>
</li>
<li><p><code>cow_page</code>，为这个<em>cowpage</em>分配新的物理页，该函数需要考虑两个情况</p>
<ul>
<li>一是这个<em>cowpage</em>只有一个引用了，我们直接修改<code>pte</code>的值即可</li>
<li>二是这个<em>cowpage</em>有多个引用，这时就要调用<code>kalloc()</code>了</li>
<li>调用<code>mappages</code>去映射时，将<code>PTE_V</code>清掉，防止<code>panic: remap</code></li>
<li>注意最后要将<code>ref_count</code>减<code>1</code></li>
</ul>
</li>
<li><p>如果不是<em>cowpage</em>或者分配失败都会将其<code>kill</code>掉，之后变成<em>zombie process</em></p>
</li>
<li><p>处理完<em>cowpage</em>引发的<code>page fault</code>，要回到原来的程序计数器（<code>pc</code>）自己重新执行即可，<br>万万不能将<code>pc</code>增加<code>4</code></p>
</li>
<li><p>记得要添加到声明到<code>defs.h</code>中</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/trap.c */</span></span><br><span class="line">...</span><br><span class="line">		syscall();</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span>)&#123;  </span><br><span class="line">    <span class="comment">// This is &quot;store page fault&quot;, because I want write a page without PTE_W  </span></span><br><span class="line">    uint64 fault_va = r_stval();</span><br><span class="line">    <span class="keyword">if</span>(fault_va &gt; p-&gt;sz ||</span><br><span class="line">       is_cowpage(p-&gt;pagetable, fault_va) &lt; <span class="number">0</span> ||</span><br><span class="line">       cow_alloc(p-&gt;pagetable, PGROUNDDOWN(fault_va)) == <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* It is cowpage? */</span></span><br><span class="line"><span class="comment">/* if YES return 0; else return -1 */</span></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">is_cowpage(<span class="keyword">pagetable_t</span> pagetable, uint64 va) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pte_t</span>* pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (*pte &amp; PTE_COW ? <span class="number">0</span> : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocte a phycial memory page for a cow page */</span></span><br><span class="line"><span class="comment">/* if OK return memory pointer of void*; else return 0 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>*</span></span><br><span class="line"><span class="function"><span class="title">cow_alloc</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  uint64 pa = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// refcount == 1, only a process use the cowpage</span></span><br><span class="line">  <span class="comment">// so we set the PTE_W of cowpage and clear PTE_COW of the cowpage</span></span><br><span class="line">  <span class="keyword">if</span>(get_refcount(pa) == <span class="number">1</span>)&#123;</span><br><span class="line">    *pte |= PTE_W;</span><br><span class="line">    *pte &amp;= ~PTE_COW;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)pa;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// refcount &gt;= 2, some processes use the cowpage</span></span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="keyword">char</span> *new_mem;</span><br><span class="line">  <span class="comment">/* sets PTE_W */</span></span><br><span class="line">  *pte |= PTE_W;</span><br><span class="line">  flags = PTE_FLAGS(*pte);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* alloc and copy, then map */</span></span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  new_mem = kalloc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If a COW page fault occurs and there&#x27;s no free memory, the process should be killed.</span></span><br><span class="line">  <span class="keyword">if</span>(new_mem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  memmove(new_mem, (<span class="keyword">char</span>*)pa, PGSIZE);</span><br><span class="line">  <span class="comment">/* clear PTE_V before map the page to avoid panic of &#x27;remap&#x27;  */</span></span><br><span class="line">  *pte &amp;= ~PTE_V;</span><br><span class="line">  <span class="comment">/* note: new_mem is new address of phycial memory*/</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, PGSIZE, (uint64)new_mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">/* set PTE_V, then kfree new_men, if map failed*/</span></span><br><span class="line">    *pte |= PTE_V;</span><br><span class="line">    kfree(new_mem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* decrement a ref_count */</span></span><br><span class="line">  kfree((<span class="keyword">char</span>*)PGROUNDDOWN(pa));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> new_mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>在<code>copyout</code>中，遇到<em>cowpage</em>时采用<code>usertrap</code>中处理<code>page fault</code>的方式</p>
<ul>
<li>注意如果处理失败要返回错误值<code>-1</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copyout</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">      n = len;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(is_cowpage(pagetable, va0) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// if it is a cowpage, we need a new pa0 pointer to a new memory</span></span><br><span class="line">      <span class="comment">// and if it is a null pointer, we need return error of -1</span></span><br><span class="line">      <span class="keyword">if</span> ((pa0 = (uint64)cow_alloc(pagetable, va0)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    memmove((<span class="keyword">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>完成日期<em>22.4.20</em></li>
<li>期间比较难以想到的就是实现<code>ref_count</code>减少<code>1</code>，在<code>kfree</code>中添加这一功能，所有的物理页面取消映射时，最终都会调用<code>kfree</code>，因为要将其释放掉。<br><em>22.5.29</em>：其实最好还是把这个功能给分开出来，不然容易混淆，不是好代码</li>
<li>debug一段时间，最好不要超过2小时，要立刻去休息，不然容易发懵</li>
<li>最近在听《萱草花》乃琳/珈乐和《北方》任素汐</li>
<li>result<br><img src="https://s2.loli.net/2022/04/22/Dbej5UMxwqTJnGz.png"></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"># c</a>
              <a href="/tags/OS/" rel="tag"># OS</a>
              <a href="/tags/xv6/" rel="tag"># xv6</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/10/MIT6.S081-Lab%20Traps/" rel="prev" title="Lab Traps">
      <i class="fa fa-chevron-left"></i> Lab Traps
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/04/MIT6.S081-Lab%20Multithreading/" rel="next" title="Lab Multithreading">
      Lab Multithreading <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab-COW"><span class="nav-number">1.</span> <span class="nav-text">Lab COW</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="nav-number">1.1.</span> <span class="nav-text">写在前面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Virtual-address"><span class="nav-number">1.1.1.</span> <span class="nav-text">Virtual address</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">1.1.2.</span> <span class="nav-text">参考链接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Copy-on-Write"><span class="nav-number">1.2.</span> <span class="nav-text">Copy-on-Write</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Huang Jinhong</p>
  <div class="site-description" itemprop="description">“我们来到这世上是为的是看太阳”</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/duilec" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;duilec" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/duile" title="博客园 → https:&#x2F;&#x2F;www.cnblogs.com&#x2F;duile" rel="noopener" target="_blank"><i class="fab fa-cnblog fa-fw"></i>博客园</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Huang Jinhong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"fflLscOo9DyB8Fx8ubGOzkl5-MdYXbMMI","app_key":"RrGHmVsgcizeqfrfsKcX4Sko","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'fflLscOo9DyB8Fx8ubGOzkl5-MdYXbMMI',
      appKey     : 'RrGHmVsgcizeqfrfsKcX4Sko',
      placeholder: "发表评论",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
